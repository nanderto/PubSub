//-----------------------------------------------------------------------
// <copyright file="PublishSubscribeChannel.cs" company="The Phantom Coder">
//     Copyright The Phantom Coder. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
namespace Phantom.PubSub
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Timers;
    using System.Transactions;
    using Phantom.PubSub;

    /// <summary>
    /// PublishSubscribeChannel will accepts new messages puts them on a queue and fire calls to all subscribers
    /// </summary>
    /// <typeparam name="T">The Type that you wish tp publish each type requires its own implementation</typeparam>
    public class PublishSubscribeChannel<T> : IPublishSubscribeChannel<T>
    {                
        private IStoreProvider<T> storeageProvider;

        private Dictionary<string, Tuple<string, Type, TimeSpan>> subscriberInfos = new Dictionary<string, Tuple<string, Type, TimeSpan>>();
        
        public PublishSubscribeChannel()
        {
        }

        public PublishSubscribeChannel(IStoreProvider<T> queueProvider)
        {
            this.storeageProvider = queueProvider;
        }
        
        /// <summary>
        /// Publishes a message first by placing on a durable Queue, then passing the message to a new thread for processing.
        /// Returns as soon as the message is succesfully on the Queue.
        /// This component does not read the message from the Que to start processing. It takes the same message that is added to the Queue and starts processing
        /// as soon as it is guaranteed to be on the queue.
        /// </summary>
        /// <param name="message">The message of the type specified to process</param>
        public void PublishMessage(T message)
        {
            if (!BatchProcessor<T>.IsConfigured)
            {
                BatchProcessor<T>.ConfigureWithPubSubChannel(this);
            }

            if (this.subscriberInfos.Count == 0)
            {
                foreach (var item in AutoConfig<T>.SubscriberInfos)
                {
                    this.subscriberInfos.Add(item.Item1, new Tuple<string, Type, TimeSpan>(item.Item1, item.Item2, item.Item3));
                }
            }

            List<ISubscriberMetadata> metadatalist = new List<ISubscriberMetadata>();

            foreach (var item in this.subscriberInfos)
            {
                var subscribermetadata = new SubscriberMetadata()
                {
                    Name = item.Key, 
                    TimeToExpire = item.Value.Item3,
                    StartTime = DateTime.Now,
                };
                metadatalist.Add(subscribermetadata);
            }

            var messageForQueue = new MessagePacket<T>(message, metadatalist);

            string result = this.storeageProvider.PutMessage(messageForQueue);
            Task.Factory.StartNew(() => this.HandleMessageForFirstTime(messageForQueue, result));
        }

        /// <summary>
        /// Batch processing alternative, this is used as part of the clean up process for Messages that expire prior to being handled. 
        /// </summary>
        public void ProcessBatch()
        {
            this.storeageProvider.ProcessStoreAsBatch(this.HandleMessageForBatchProcessing);
        }

        /// <summary>
        /// This method receives a single message and processes all of the subscribers for each individual message. The subscribers are processed in parallel
        /// to ensure that one long running process will not impact the others.
        /// When all subscribers have indicate they have completed a flag is set to indicate that this message has completed publishing, and it is removed 
        /// from the Queue
        /// This method uses the Parallel.ForEach method, so Visual Studio parallel debugging can be used.
        /// </summary>
        /// <param name="messagePacket">THe message being sent inside of the messagepacket wrapper</param>
        /// <param name="messageId">ID of message generated by the queue in mechanism</param>
        /// <returns>True on success</returns>
        public bool HandleMessageForFirstTime(MessagePacket<T> messagePacket, string messageId)
        {
            if (messagePacket == null)
            {
                throw new ArgumentNullException("messagePacket");
            }

            if (string.IsNullOrEmpty(messageId))
            {
                throw new ArgumentNullException("messagePacket");
            }

            var subscribersForThisMessage = this.GetSubscriptions();

            this.RunSubscriptions(messagePacket, messageId, subscribersForThisMessage);
            return true;
        }

        public bool HandleMessageForBatchProcessing(MessagePacket<T> messagePacket, string messageId)
        {
            if (messagePacket == null)
            {
                throw new ArgumentNullException("messagePacket");
            }

            if (string.IsNullOrEmpty(messageId))
            {
                throw new ArgumentNullException("messagePacket");
            }
            
            if (messagePacket.SubscriberMetadataList.Count == 1)
            {
                return this.HandleSingleSubscriberforMessage(messagePacket, messageId);
            }

            ////Trace.WriteLine("In HandleMessageForBatchProcessing, Subscriber Count NOT 1 so doing nothing message: " + messageId);

            ////we may see this called but it should be a timing issue
            ////expired subscriptions get a new message in the que and the original message removed

            foreach (var item in messagePacket.SubscriberMetadataList)
            {
                if (item.CanProcess())
                {
                    this.HandleMessageForFirstTime(messagePacket, messageId);
                    break;
                }
            }

            return true;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Its Appropriate")]
        public SubscribersCollection<T> GetSubscriptions()
        {
            if (this.subscriberInfos == null || this.subscriberInfos.Count == 0)
            {
                throw new InvalidOperationException("There are no subscribers set up for this channel");
            }

            var subscribers = new SubscribersCollection<T>();
            foreach (var item in this.subscriberInfos)
            {
                ISubscriber<T> subscriber = (ISubscriber<T>)Activator.CreateInstance(item.Value.Item2);
                subscriber.Name = item.Value.Item1;
                subscriber.TimeToExpire = item.Value.Item3;
                subscribers.Add(subscriber);
            }

            return subscribers;
        }

        public ISubscriberInfo<T> AddSubscriberType(Type type)
        {
            return new SubscriberInfo<T>(type, this);
        }

        public IPublishSubscribeChannel<T> AddSubscriberInfo(Tuple<string, Type, TimeSpan> tuple)
        {
            if (tuple == null)
            {
                throw new ArgumentNullException("tuple");
            }

            this.subscriberInfos.Add(tuple.Item1, tuple);
            return this;
        }

        ////private static bool HasExpired(ISubscriberMetadata subscriberMetaData)
        ////{
        ////    var nextstart = subscriberMetaData.StartTime + subscriberMetaData.TimeToExpire;
        ////    if (DateTime.Compare(DateTime.Now, nextstart) > 0)
        ////    {
        ////        return true;
        ////    }

        ////    return false;
        ////}

        private static string GetSubscriptionId(string messageId, string subscriberName)
        {
            StringBuilder sb = new StringBuilder();
            return sb.Append(":SubScriber::").Append(subscriberName).Append("::MessageID::").Append(messageId).Append(":").ToString();
        }

        private static MessagePacket<T> CreateSingleSubscriberMessagePacket(ISubscriber<T> subscriber, MessagePacket<T> messagePacket)
        {
            Counter.Increment(19);
            ////Trace.WriteLine("In CreateSingleSubscriberMessagePacket ");

            List<ISubscriberMetadata> metadatalist = new List<ISubscriberMetadata>();
            var subscribermetadata = new SubscriberMetadata()
            {
                ////need to add abort count and think thru appropriate start time
                Name = subscriber.GetType().Name,
                TimeToExpire = subscriber.TimeToExpire,
                StartTime = subscriber.StartTime,
                RetryCount = ++subscriber.AbortCount,
                FailedOrTimedOutTime = subscriber.AbortedTime
            };
            metadatalist.Add(subscribermetadata);
            return new MessagePacket<T>((T)messagePacket.Body, metadatalist);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Error message needs to be swallowed, next processing run will try again")]
        private bool HandleSingleSubscriberforMessage(MessagePacket<T> messagePacket, string messageId)
        {
            var metaData = messagePacket.SubscriberMetadataList[0];
            string subscriptionId = GetSubscriptionId(messageId, metaData.Name);
            ////Trace.WriteLine("About to check if I can process: " + subscriptionId);

            ISubscriber<T> newSubscription = null;

            if (metaData.CanProcess())
            {
                var subscriberInfo = this.subscriberInfos.FirstOrDefault(si => si.Key == metaData.Name);
                newSubscription = (ISubscriber<T>)Activator.CreateInstance(subscriberInfo.Value.Item2);
                newSubscription.Name = subscriberInfo.Value.Item1;
                newSubscription.TimeToExpire = subscriberInfo.Value.Item3;
                newSubscription.Id = subscriptionId;

                var cancellationTokenSource = new CancellationTokenSource(newSubscription.TimeToExpire);

                Task.Run(async () =>
                {
                    await newSubscription.RunAsync((T)messagePacket.Body, cancellationTokenSource.Token);
                    return true;
                })
                .ContinueWith(anticedant =>
                {
                    switch (anticedant.Status)
                    {
                        case TaskStatus.RanToCompletion:
                            Counter.Increment(16);
                            this.storeageProvider.RemoveFromStorage(messageId);
                            break;
                        case TaskStatus.Faulted:
                            try
                            {
                                this.storeageProvider.PutMessage(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
                                Counter.Increment(20);
                            }
                            catch
                            {
                                break;
                            }

                            this.storeageProvider.RemoveFromStorage(messageId);
                            break;
                        case TaskStatus.Canceled:
                            try
                            {
                                this.storeageProvider.PutMessage(CreateSingleSubscriberMessagePacket(newSubscription, messagePacket));
                                Counter.Increment(18);
                                Trace.WriteLine("Request was canceled");
                            }
                            catch
                            {
                                break;
                            }

                            this.storeageProvider.RemoveFromStorage(messageId);
                            break;
                    }

                    cancellationTokenSource.Dispose();
                });
            }

            return true;
        }

        ////private bool IsReady()
        ////{
        ////    if (this.storeageProvider == null)
        ////    {
        ////        return false;
        ////    }

        ////    if (this.subscriberInfos.Count == 0)
        ////    {
        ////        return false; // will not work with no subscribers
        ////    }

        ////    return true;
        ////}

        private void RunSubscriptions(MessagePacket<T> messagePacket, string messageId, SubscribersCollection<T> subscribersForThisMessage)
        {
            Task.Run(async () =>
            {
                foreach (var subscriber in subscribersForThisMessage)
                {
                    string newSubscriptionId = GetSubscriptionId(messageId, subscriber.Name);
                    subscriber.Id = newSubscriptionId;
                    subscriber.MessageId = messageId;
                    var cancellationToken = new CancellationTokenSource(subscriber.TimeToExpire).Token;

                    try
                    {
                        bool result = await subscriber.RunAsync((T)messagePacket.Body, cancellationToken);
                        Counter.Increment(14);
                    }
                    catch (OperationCanceledException)
                    {
                        subscriber.Abort();
                        this.storeageProvider.PutMessage(CreateSingleSubscriberMessagePacket(subscriber, messagePacket));
                        Counter.Increment(12);
                        Trace.WriteLine("This task timed out : " + subscriber.Name + " The timeout timespan was: " + subscriber.TimeToExpire.TotalMilliseconds + " ms");
                    }
                    catch (Exception)
                    {
                        subscriber.Abort();
                        var newMessagId = this.storeageProvider.PutMessage(CreateSingleSubscriberMessagePacket(subscriber, messagePacket));
                        Counter.Increment(13);
                        ////Trace.WriteLine("Request failed: " + newSubscriptionId + " newMessagId" + newMessagId + " " + anticedant.Exception.InnerException.ToString());    
                    }
                }
            }).ContinueWith((Anticedant) =>
            {
                this.storeageProvider.RemoveFromStorage(messageId);
            });
        }
    }
}
